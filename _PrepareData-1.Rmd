---
title: "My R Codes For Data Analysis"
subtitle: "In this repository I am going to collect `R codes` for data analysis. Codes are from various resources and I try to give original link as much as possible."
author: "[Serdar BalcÄ±, MD, Pathologist](https://www.serdarbalci.com/)"
date: '`r # format(Sys.Date())`'
output: 
  html_notebook: 
    fig_caption: yes
    highlight: tango
    number_sections: yes
    theme: paper
    toc: yes
    toc_depth: 5
    toc_float: yes
  html_document: 
    code_folding: hide
    df_print: kable
    keep_md: yes
    number_sections: yes
    theme: cerulean
    toc: yes
    toc_float: yes
    highlight: kate
---


# Prepare Data for Analysis / Veriyi Analiz iÃ§in hazÄ±rlamak

## The Quartz guide to bad data

>    An exhaustive reference to problems seen in real-world data along with suggestions on how to resolve them.

https://github.com/Quartz/bad-data-guide


## KÃ¶tÃ¼ veri kÄ±lavuzu

KÃ¶tÃ¼ veri kÄ±lavuzu

https://sbalci.github.io/Kotu-Veri-Kilavuzu/index.html

## data organization organizing data in spreadsheets

https://kbroman.org/dataorg/

Daniel Kaplan. (2018) Teaching Stats for Data Science. The American Statistician 72:1, pages 89-96. 

https://doi.org/10.1080/00031305.2017.1375989


## Tidy Data

Hadley Wickham.
Tidy data.
The Journal of Statistical Software, vol. 59, 2014.

http://vita.had.co.nz/papers/tidy-data.html
https://www.jstatsoft.org/article/view/v059i10
http://dx.doi.org/10.18637/jss.v059.i10


## The Ten Commandments for a well-formatted database

- The Ten Commandments for a well-formatted database

https://rtask.thinkr.fr/blog/the-ten-commandments-for-a-well-formatted-database/


## Software specific problems

### Keep SPSS labels

```r
library(foreign) # foreign paketi yÃ¼kleniyor
```

read.spss komutu ile deÄŸer etiketlerini almasÄ±nÄ± ve bunu liste olarak deÄŸil de data.frame olarak kaydetmesini istiyoruz

```r
mydata <- read.spss("mydata.sav", use.value.labels = TRUE, to.data.frame = TRUE)
```

aktardÄ±ÄŸÄ±mÄ±z data.frame'in Ã¶zellikleri (attr) iÃ§inde deÄŸiÅŸkenlerin etiketleri var, bunlarÄ± dÄ±ÅŸarÄ± Ã§Ä±kartÄ±yoruz

```r
VariableLabels <- as.data.frame(attr(mydata, "variable.labels"))
```


elde ettiÄŸimiz data.frame'deki satÄ±r isimleri deÄŸiÅŸkenlerin isimleri oluyor, karÅŸÄ±larÄ±nda da deÄŸiÅŸken etiketleri var
satÄ±r isimlerini de dÄ±ÅŸarÄ± Ã§Ä±kartÄ±yoruz

```r
VariableLabels$original <- rownames(VariableLabels)
```

DeÄŸiÅŸken etiketi olanlarÄ± etiketleri ile diÄŸerlerini olduÄŸu gibi saklÄ±yoruz  

```r
VariableLabels$label[VariableLabels$label ==""] <- NA 
VariableLabels$colname <- VariableLabels$original
VariableLabels$colname[!is.na(VariableLabels$label)] <- as.vector(VariableLabels$label[!is.na(VariableLabels$label)])
```

son olarak da data.frame'deki sÃ¼tun isimlerini deÄŸiÅŸtiriyoruz

```r
names(mydata) <- VariableLabels$colname
```


### Make both computer and human readible variable names

turkce karakter donusumu

```{r turkce karakter donusumu}
# https://suatatan.wordpress.com/2017/10/07/bulk-replacing-turkish-characters-in-r/

to.plain <- function(s) {
        # 1 character substitutions
    old1 <- "Ã§ÄŸÅŸÄ±Ã¼Ã¶Ã‡ÄžÅžÄ°Ã–Ãœ"
    new1 <- "cgsiuocgsiou"
    s1 <- chartr(old1, new1, s)
    # 2 character substitutions
    old2 <- c("Å“", "ÃŸ", "Ã¦", "Ã¸")
    new2 <- c("oe", "ss", "ae", "oe")
    s2 <- s1
    for(i in seq_along(old2)) s2 <- gsub(old2[i], new2[i], s2, fixed = TRUE)
    s2
}

names(df) <- make.names(to.plain(tolower(names(df))))

names(df) <- names(df) %>% 
    tolower() %>% 
    to.plain() %>% 
    make.names()

df$source=as.vector(sapply(df$source,to.plain))

make.names(tolower(names(df)))
to.plain(names(df))

purrr::map(df, to.plain)

```

### Anonimisation

### Add subject ID to the data / veriye ID ekleme

```r
df <- tibble::rowid_to_column(df, "subject")
```





## Data reorganization

```r
scabies <- read.csv(file = "http://datacompass.lshtm.ac.uk/607/2/S1-Dataset_CSV.csv", header = TRUE, sep = ",")

scabies$gender == "male"

scabies$age[scabies$gender == "male"]

mean(scabies$age[scabies$gender == "male"])


scabies %>% 
    filter(gender == "male") %>% 
    summarise_at("age" ,mean) 


```



```r

scabies$agegroups <- as.factor(cut(scabies$age, c(0,10,20,Inf), labels = c("0-10","11-20","21+"), include.lowest = TRUE)) 

scabies$house_cat <- as.factor(cut(scabies$house_inhabitants, c(0,5,10,Inf), labels = c("0-5","6-10","10+"), include.lowest = TRUE))


table(scabies$house_cat, scabies$house_inhabitants)

```

```r
ebola$status <- as.numeric(ebola$status) 

```


```r
ebola$transmission <- recode(ebola$transmission, syringe = "needle")

```

```r
scabies$house_cat <- relevel(scabies$house_cat, ref = "0-5")
#Make 0-5 household size the baseline group
```





```r
df <- data.frame(month=rep(1:3,2),
                 student=rep(c("Amy", "Bob"), each=3),
                 A=c(9, 7, 6, 8, 6, 9),
                 B=c(6, 7, 8, 5, 6, 7))
#Here we have a where each student is on a different row for each month
#The students took two tests A and B. 
#For each student/month combination we have a value for A and a value for B

df2 <- gather(df,test,score,A:B)
#Make a new datatable df2
#Have a column called "test". 
#This will have the value either A or B as these are the names of the columns we specified.
#Have a column called "score". 
#This will have the value previously in column A or B respectively for each row

df2
```


```r
#Now we have a single row for each combination of month/student/test 
#Their score is in the score column

df3 <- spread(df2,test,score)
#Make a new datatable df3
#Make a column for each unique value in the test variable.
#Name each of these columns based on that unique value
#Under each column put the corresponding value that was in the score column

df3
```

```r
dt3 <- expandRows(dt, 2)
#Expand the original datatable. Replicate each row by the value in column 2. 
dt3
```










































<!-- # gerekli paketi yÃ¼kleme -->
<!-- library(tidyverse) -->
<!-- library(haven) -->
<!-- # dosyayÄ± yÃ¼kleme -->
<!-- EDT256 <- read_sav("EDT256.sav") -->



<!-- # gerekli sÃ¼tunlarÄ± seÃ§me -->
<!-- EDT256 <- EDT256 %>% -->
<!--     select(subject, tanÄ±, starts_with("beck")) -->

<!-- # deÄŸiÅŸken deÄŸerlerini yeniden atama -->
<!-- EDT256$tanÄ± <- as_factor(EDT256$tanÄ±, labels = "values") -->

<!-- # yatay veriyi uzun hale getirme -->
<!-- EDT256_new <- EDT256 %>% -->
<!--     gather(- c("subject","tanÄ±"), key = zaman, value = beck_int_score) -->


<!-- # deÄŸiÅŸkenleri rakamsal hale getirme -->
<!-- EDT256_new$zaman[which(EDT256_new$zaman == "beck_int_P")] <- 0 -->
<!-- EDT256_new$zaman[which(EDT256_new$zaman == "beck_int_A1")] <- 1 -->
<!-- EDT256_new$zaman[which(EDT256_new$zaman == "beck_int_A2")] <- 2 -->

<!-- # deÄŸiÅŸken deÄŸerlerini atama  -->
<!-- EDT256_new$zaman <- factor(EDT256_new$zaman, levels = c(0,1,2), -->
<!--                            labels = c("Tedavi Ã–ncesi", "T. SonrasÄ± 1. Hafta", -->
<!--                                       "T. SonrasÄ± 2. Hafta")) -->


<!-- # nparLD analizi -->

<!-- # gerekli paketi yÃ¼kleme -->
<!-- library(nparLD) -->

<!-- # model oluÅŸturma -->
<!-- modelEDT256 <- nparLD(beck_int_score ~ tanÄ± * zaman, data = EDT256_new, -->
<!--                       subject = "subject", -->
<!--                       plot.CI = TRUE, show.covariance = TRUE) -->

<!-- # model sonucunu yazdÄ±r -->
<!-- out <- capture.output(modelEDT256) -->
<!-- cat("EDT256 Model", out, file = "EDT256.txt", sep = "\n", append=TRUE) -->

<!-- # model grafiÄŸi -->
<!-- plot(modelEDT256) -->

<!-- # plot sonucunu yazdÄ±r -->
<!-- out2 <- capture.output(plot(modelEDT256)) -->
<!-- cat("\n","EDT256 Plot", out2, file = "EDT256.txt", sep = "\n", append = TRUE) -->

<!-- # grafiÄŸi yazdÄ±r -->
<!-- jpeg('modelEDT256.jpeg') -->
<!-- plot(modelEDT256) -->
<!-- dev.off() -->

<!-- # model Ã¶zeti -->
<!-- summary(modelEDT256) -->

<!-- # model Ã¶zeti sonucunu yazdÄ±r -->
<!-- out3 <- capture.output(modelEDT256) -->
<!-- cat("\n","EDT256 summary", out3, file = "EDT256.txt", sep = "\n", append=TRUE) -->


<!-- # ek olarak boxplot oluÅŸturma -->
<!-- boxplot(beck_int_score ~ tanÄ± * zaman, data = EDT256_new, -->
<!--         names = FALSE,col = c("grey",2),lwd = 2) -->
<!-- axis(1,at = 1.5,labels = "Tedavi Ã–ncesi",font = 2,cex = 3) -->
<!-- axis(1,at = 3.5,labels = "T. SonrasÄ± 1. Hafta",font = 2,cex = 3) -->
<!-- axis(1,at = 5.5,labels = "T. SonrasÄ± 2. Hafta",font = 2,cex = 3) -->
<!-- legend(5,35,c("TanÄ± 1","TanÄ± 2"), -->
<!--        lwd = c(2,2), -->
<!--        col = c("grey",2),cex = 0.7) -->

<!-- # boxplot yazdÄ±r -->
<!-- jpeg('boxplotEDT256.jpeg') -->
<!-- boxplot(beck_int_score ~ tanÄ± * zaman, data = EDT256_new, -->
<!--         names = FALSE,col = c("grey",2),lwd = 2) -->
<!-- axis(1,at = 1.5,labels = "Tedavi Ã–ncesi",font = 2,cex = 3) -->
<!-- axis(1,at = 3.5,labels = "T. SonrasÄ± 1. Hafta",font = 2,cex = 3) -->
<!-- axis(1,at = 5.5,labels = "T. SonrasÄ± 2. Hafta",font = 2,cex = 3) -->
<!-- legend(5,35,c("TanÄ± 1","TanÄ± 2"), -->
<!--        lwd = c(2,2), -->
<!--        col = c("grey",2),cex = 0.7) -->
<!-- dev.off() -->


https://stackoverflow.com/questions/22353633/filter-for-complete-cases-in-data-frame-using-dplyr-case-wise-deletion


df %>% na.omit
or this:

df %>% filter(complete.cases(.))
or this:

library(tidyr)
df %>% drop_na
If you want to filter based on one variable's missingness, use a conditional:

df %>% filter(!is.na(x1))
or

df %>% drop_na(x1)
Other answers indicate that of the solutions above na.omit is much slower but that has to be balanced against the fact that it returns and row indices of the omitted rows as the na.action attribute whereas the other solutions above do not.

str(df %>% na.omit)
'data.frame':   2 obs. of  2 variables:
$ x1: num  1 2
$ x2: num  1 2
- attr(*, "na.action")= 'omit' Named int  3 4
    ..- attr(*, "names")= chr  "3" "4"



ozp <- veri %>% 
    select(RaporNo, Hasta, cinsiyet, Yas,
           ozp_parca, ozp_kaset, ozp_cap, ozp_tani, ozp_kod) %>% 
    filter(!is.na(ozp_parca) | !is.na(ozp_kaset) | !is.na(ozp_cap) | !is.na(ozp_tani) | !is.na(ozp_kod)
    )

ozp2 <- veri %>% 
    select(RaporNo, Hasta, cinsiyet, Yas,
           ozp_parca, ozp_kaset, ozp_cap, ozp_tani, ozp_kod) %>% 
    filter(complete.cases(ozp_parca, ozp_kaset, ozp_cap, ozp_tani, ozp_kod)
    )

ozp3 <- veri %>% 
    select(RaporNo, Hasta, cinsiyet, Yas,
           ozp_parca, ozp_kaset, ozp_cap, ozp_tani, ozp_kod) %>% 
    na.omit(ozp_parca, ozp_kaset, ozp_cap, ozp_tani, ozp_kod)
    


# xray

The R Package to Have X Ray Vision on your Datasets

https://blog.datascienceheroes.com/x-ray-vision-on-your-datasets/



```r
# install.packages("devtools")
devtools::install_github("sicarul/xray")
```



```r
data(longley)
badLongley <- longley
badLongley$GNP <- NA
xray::anomalies(badLongley)
```


```r
distrLongley <- longley
distrLongley$testCategorical <- c(rep('One',7), rep('Two', 9))
xray::distributions(distrLongley)
```


```r
dateLongley <- longley
dateLongley$Year <- as.Date(paste0(dateLongley$Year,'-01-01'))
dateLongley$Data <- 'Original'
ndateLongley <- dateLongley
ndateLongley$GNP <- dateLongley$GNP+10
ndateLongley$Data <- 'Offseted'
xray::timebased(rbind(dateLongley, ndateLongley), 'Year')
```


# convert all data.frame into character

df <- purrr::map_df(df, as.character)



# R:case4base - reshape data with base R

https://jozefhajnala.gitlab.io/r/r002-data-manipulation/

# R:case4base - data aggregation with base R

https://jozefhajnala.gitlab.io/r/r003-aggregation/

# tidyr

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">This week I&#39;m going to be looking at some <a href="https://twitter.com/hashtag/tidyr?src=hash&amp;ref_src=twsrc%5Etfw">#tidyr</a> functions! ðŸ’¡ First is uncount() which might come in handy if you want to transform a summary table to individual rows. <a href="https://twitter.com/hashtag/rstats?src=hash&amp;ref_src=twsrc%5Etfw">#rstats</a> <a href="https://t.co/UZE0wUcEHC">pic.twitter.com/UZE0wUcEHC</a></p>&mdash; Nic Crane (@nic_crane) <a href="https://twitter.com/nic_crane/status/1066964776276893696?ref_src=twsrc%5Etfw">November 26, 2018</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>




---

```
df <- data.frame(
          V1 = c(0, 0, 0, 0, 1, 1, 1, 1, 0, 1),
          V2 = c(1, 1, 1, 0, 0, 0, 0, 0, 0, 1),
          V3 = c(0, 0, 0, 1, 1, 1, 1, 1, 0, 1)
)


df$V1_rec <- grepl(pattern = "0", x = df$V1)
df$V2_rec <- grepl(pattern = "0", x = df$V2)
df$V3_rec <- grepl(pattern = "0", x = df$V3)

df %>% 
    mutate(toplam = select(., V1_rec:V3_rec) %>% rowSums(na.rm = TRUE)
               )
```

---



















